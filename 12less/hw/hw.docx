Контрольные вопросы

1 — Вычисления на этапе компиляции. 

Можно (с помощью шаблонов):
	-узнать тип
	-вычислить размер строки/массива
	-посчитать рекурсивно значение функции 
	-посчитать значение вычислимой функции

2 — Языковые механизмы на этапе компиляции. 
	
Процесс компиляции состоит из следующих этапов:

    1. Лексический анализ. 
       Последовательность символов исходного файла преобразуется в последовательность лексем. 
    2. Синтаксический анализ. 
       Последовательность лексем преобразуется в дерево разбора. 
    3. Семантический анализ. 
       Дерево разбора обрабатывается с целью установления его семантики (смысла)— например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т.д. 
    4. Оптимизация. 
       Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла. 
    5. Генерация кода. 
       Из промежуточного представления порождается объектный код. 

3 — Ограничения метапрограммирования шаблонов.

	- ограничения существуют на число параметров шаблона 
	ограничения по времени (например, в глубоких рекурсиях)
	- невозможность работать с некоторыми типами (double)

4 — Идиома SFINAE.

SFINAE расшифровывается как substitution failure is not an error и означает: при определении перегрузок функции ошибочные инстанциации шаблонов не вызывают ошибку компиляции, а отбрасываются из списка кандидатов на наиболее подходящую перегрузку. 

    • Это работает при автоматическом выводе типов шаблона (type deduction) по аргументам функции. 
    • Некоторые перегрузки могут отбрасываться в том случае, когда их невозможно инстанциировать из-за возникающей синтаксической ошибки; компиляция при этом продолжается как ни в чём не бывало, без ошибок. 
    • Отбросить могут только шаблон. 
    • SFINAE рассматривает только заголовок функции, ошибки в теле функции не будут пропущены. 

5 — Вспомогательный шаблон std::enable_if.

Вид:
temeplate < bool B, class T = void>
struct enable_if;

Если B -  true,  enable_if имеет публичный член typedef type T; в противном случае член typedef отсутствует.
Эта метафункция - удобный способ использования SFINAE для условного удаления функций из разрешения перегрузки на основе свойств типа и для предоставления отдельных перегрузок функций и специализаций для различных свойств типа, условно создает экземпляр типа для разрешения перегрузки SFINAE.  enable_if можно использовать как дополнительный аргумент функции, как тип возвращаемого значения  или как шаблон класса или параметр шаблона функции.

